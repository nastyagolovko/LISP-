; 9. Определите функцию, разделяющую исходный список на два подсписка. В
первый из них должны попасть элементы с нечетными номерами, во второй —
элементы с четными номерами.


(defun chet-nechet (x)
  ; цикл с счетчиком i по всем элементам списка x
  (loop for i in x
		; если четный
        if (evenp i)
        ; то записываем этот элемент в список evens
        collect i into evens
        ; иначе записываем этот элемент в список odds
        else collect i into odds
        ; возвращаем эти списки
        finally (return (values evens odds))))
        
; проверка
(write (chet-nechet '(1 2 2 3 10 8 4)))





; 20. Определите функцию ПЕРВЫЙ-АТОМ, результатом которой будет первый атом списка. Пример:
; > (ПЕРВЫЙ-АТОМ '(((a b)) c d))
; A

(defun ПЕРВЫЙ-АТОМ (w)
  ; если список пустой, возвращаем nil
  (cond ((null w) nil)
		; функция listp - проверяет, является ли аргумент списком
		; если нет, то рекурсивно вызываем нашу функцию ПЕРВЫЙ-АТОМ и двигаемся дальше по списку
        ((listp (car w)) (ПЕРВЫЙ-АТОМ (car w)))
     
        ((car w))))
        
; проверка
(write (ПЕРВЫЙ-АТОМ '(((a b)) c d)))


; 26. Определите функцию, разбивающую список (a b с d...) на пары ((а b) (с d)...).
; Определяем функцию с именем "пары" с одним входным параметром - списком
(defun пары (w)
   (cond ((null (cdr w) w)
            (t (cons (list (car w) (cadr w)) (пары (cddr w)))))))
        
; проверка
(write (пары '(a b c d)))


; 28. Определите функцию, вычисляющую, сколько всего атомов в списке (списочной структуре).
; Определяем функцию с именем "сколько_атомов" с одним входным параметром - списком
(defun сколько_атомов (w)
	; если список пустой, то возвращаем ноль
    (if (null w)
        0
        ; иначе, берем голову списка и если это атом, то
        ; увеличиваем "счетчик" на единичку и в конце возвращаем его
        ; и так далее( рекурсивно вызываем нашу функцию "сколько_атомов" для хвоста списка)
        (+ (if (atom (car w)) 1 0) (сколько_атомов (cdr w)))))
    
; проверка
(write (сколько_атомов '(a b c d)))


; 39. Определите функцию СИММЕТРИЧЕСКАЯ-РАЗНОСТЬ, формирующую множество из элементов не входящих в оба множества.
; Определяем функцию с именем "СИММЕТРИЧЕСКАЯ-РАЗНОСТЬ" с одним входным параметром – списком

(defun СИММЕТРИЧЕСКАЯ-РАЗНОСТЬ (list1 list2)
  ; заведем переменную res 
  (let ((res nil))
	; в цикле с счетчиком i по всем элементам списка list1
	; если элемент i из списка list1 не найден в списке list2 (для этого используем функцию member), то записываем его в список res
    (iter (for i in list1) (unless (member i list2) (collecting i into res)))
    ; тоже самое делаем для второго списка list2
    (iter (for i in list2) (unless (member i list1) (collecting i into res)))
    ; возвращаем результат
    res))
 
(write (СИММЕТРИЧЕСКАЯ-РАЗНОСТЬ '(a b c d) '(a b)))




; 45. Предположим, что у имени города есть свойства х и у, которые содержат координаты места нахождения города относительно некоторого начала координат.
; Напишите функцию (РАССТОЯНИЕ a b), вычисляющую расстояние между городами а и b.

; Определяем функцию с именем "РАССТОЯНИЕ" с 2-мя входным параметрами
(defun РАССТОЯНИЕ (a b)

  ; AB = √(xb - xa)2 + (yb - ya)2
  (sqrt (+ (expt (- (get a 'x) (get b 'x)) 2)
           (expt (- (get a 'y) (get b 'y)) 2))))

; проверка - задаем расстояния для каких-то двух городов
(setf (get 'С1 'x) 0)
(setf (get 'С1 'y) 0)
 
(setf (get 'С2 'x) 30)
(setf (get 'С2 'y) 0)

; проверка
(write (РАССТОЯНИЕ 'С1 'С2))


